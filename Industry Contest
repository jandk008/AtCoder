/*
* This algorithm solves the question that counters the number of duplicated words and print them in ascend order
*/
package exam;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

public class A {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		String s = in.next();
		char[] a = s.toCharArray();
		quickSort(a, 0, a.length - 1);
		List<MyNode> myList = new ArrayList<MyNode>();
		int counter = 1;
		char c = a[0];
		MyNode node;
		for (int n = 1; n < a.length; n++) {
			if (a[n] != c) {
				node = new MyNode(c,counter);
				myList.add(node);
				c = a[n];
				counter = 1;
				if (n == a.length - 1){
					myList.add(new MyNode(c,counter));
				}
				continue;
			}
			counter++;
			if (n == a.length - 1){
				myList.add(new MyNode(c,counter));
			}
			}
		Collections.sort(myList);
//		myList.sort(new MyComparator());
		display(myList);
		in.close();
		out.close();
	}

	public static void display(List<MyNode> a) {
		for (MyNode n : a) {
			System.out.println(n.c);
		}
	}

	public static void display(char[] a) {
		for (char n : a) {
			System.out.println(n);
		}
	}

	public static void quickSort(char[] a, int low, int high) {
		if (low >= high)
			return;
		if (low + 1 == high) {
			if (a[low] > a[high]) {
				swap(a, low, high);
			}
			return;
		}
		int l = low + 1;
		int r = high;
		int pivat = a[low];
		while (l < r) {
			while (l < r && l <= high) {
				if (a[l] > pivat)
					break;
				l++;
			}
			while (r >= l && r > low) {
				if (a[r] < pivat)
					break;
				r--;
			}
			if (l < r) {
				swap(a, l, r);
			}
		}
		swap(a, low, r);
		quickSort(a, low, r);
		quickSort(a, r + 1, high);
	}

	public static void swap(char[] a, int n, int m) {
		char temp = a[m];
		a[m] = a[n];
		a[n] = temp;
	}

	public static int binarySearch(int[] a, int low, int high, int target) {
		if (low > high)
			return -1;
		int mid = (low + high) / 2;
		if (a[mid] == target) {
			return mid;
		} else if (a[mid] > target) {
			return binarySearch(a, low, mid - 1, target);
		} else {
			return binarySearch(a, mid + 1, high, target);
		}
	}
}

class MyNode implements Comparable<MyNode> {
	char c;
	int number;

	MyNode(char c, int number) {
		this.c = c;
		this.number = number;
	}

	public int compareTo(MyNode a) {
		if (this.number != a.number) {
			return a.number - this.number;
		} else {
			return this.c - a.c;
		}
	}

}

class MyComparator implements Comparator<MyNode> {
	public int compare(MyNode a, MyNode b) {
		if (a.number != b.number) {
			return b.number - a.number;
		} else {
			return a.c - b.c;
		}
	}
}

/*
* this algorithm accept K ,N and calculate the Nth to N+4th number based the formular which is N+1th = (A*K+B)%M+N
*/
package exam;

import java.io.PrintWriter;
import java.util.Scanner;

public class B {
	int a;
	int b;
	int k;
	int m;
	public static void main(String[] args) {
		new B().run();
	}

	public void run() {
		Scanner in = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		 a = in.nextInt();
		 b = in.nextInt();
		 int x1= in.nextInt();
		 k= in.nextInt();
		 m=in.nextInt();
		
		execute(x1, 1);
		
		
		in.close();
		out.close();
	}

	public  void execute(int current, int n){
		int next =(a*current+b)%m;
		if(n == k){
			System.out.println(current );
			System.out.println(next);
			for(int j=0;j<3;j++){
				next =(a*next+b)%m;
				System.out.println(next);
			}
			return;
		}
		execute(next, n+1);
	}
	public static void quickSort(int[] a, int low, int high) {
		if (low >= high)
			return;
		if (low + 1 == high) {
			if (a[low] > a[high]) {
				swap(a, low, high);
			}
			return;
		}
		int l = low + 1;
		int r = high;
		int pivat = a[low];
		while (l < r) {
			while (l < r && l <= high) {
				if (a[l] > pivat)
					break;
				l++;
			}
			while (r >= l && r > low) {
				if (a[r] < pivat)
					break;
				r--;
			}
			if(l<r){
				swap(a, l, r);
			}
		}
		swap(a, low, r);
		quickSort(a, low, r);
		quickSort(a, r+1, high);
	}

	public static void swap(int[] a, int n, int m) {
		int temp = a[m];
		a[m] = a[n];
		a[n] = temp;
	}
	public static int binarySearch(int[] a, int low,int high,int target){
		if(low >high) return -1;
		int mid = (low + high)/2;
		if (a[mid] == target){
			return mid;
		}else if(a[mid] > target){
			return binarySearch(a, low,mid-1,target);
		}else {
			return binarySearch(a, mid+1, high, target);
		}
	}
}

/*
* this algorithm iterates all path in a graph 
*/
package exam;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;

public class C {
	public static void main(String[] args) {
		new C().run();
	}

	public void run() {
		Scanner in = new Scanner(System.in);
		PrintWriter out = new PrintWriter(System.out);
		int computers = in.nextInt();
		int commands = in.nextInt();
		int[][] computer = new int[computers][computers];
		ArrayList<String> s = new ArrayList<String>();
		for (int n=0;n<computers;n++){
			for (int m=0;m<computers;m++){
				computer[n][m] = 0;
			}
		}
				
		for (int n = 0;n<commands;n++){
			String c = in.next();
			if (c.equals("make")){
				int i = in.nextInt()-1;
				int j = in.nextInt()-1;
				int time = in.nextInt();
				if(computer[i][j]==0){
				computer[i][j] = time;
				computer[j][i] = time;
				}
				else{
					if(computer[i][j]<time){
						computer[j][i] = time;
					}					
				}
				//update
				for (int a=0;a<computers;a++){
					for (int b=0;b<computers;b++){
						if(computer[i][a] ==0||computer[b][j] ==0){
							int max = Math.max(computer[i][a], computer[b][j]);
							max = Math.max(max, time);
							computer[a][b] = max;
						}
					}
				}
			}
			else{
				int i = in.nextInt()-1;
				int j = in.nextInt()-1;
				int time = in.nextInt();
				if(computer[i][j]==0){
					s.add("NO");
				}
				else if(computer[i][j]>time){
					s.add("NO");
				}
				else{
					s.add("YES");
				}
			}
		}
		
		
		
		for (String i:s){
			System.out.println(i);
		}
		
		
		
		in.close();
		out.close();
	}

	public static void quickSort(int[] a, int low, int high) {
		if (low >= high)
			return;
		if (low + 1 == high) {
			if (a[low] > a[high]) {
				swap(a, low, high);
			}
			return;
		}
		int l = low + 1;
		int r = high;
		int pivat = a[low];
		while (l < r) {
			while (l < r && l <= high) {
				if (a[l] > pivat)
					break;
				l++;
			}
			while (r >= l && r > low) {
				if (a[r] < pivat)
					break;
				r--;
			}
			if(l<r){
				swap(a, l, r);
			}
		}
		swap(a, low, r);
		quickSort(a, low, r);
		quickSort(a, r+1, high);
	}

	public static void swap(int[] a, int n, int m) {
		int temp = a[m];
		a[m] = a[n];
		a[n] = temp;
	}
	public static int binarySearch(int[] a, int low,int high,int target){
		if(low >high) return -1;
		int mid = (low + high)/2;
		if (a[mid] == target){
			return mid;
		}else if(a[mid] > target){
			return binarySearch(a, low,mid-1,target);
		}else {
			return binarySearch(a, mid+1, high, target);
		}
	}
}
